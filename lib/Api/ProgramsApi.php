<?php
/**
 * ProgramsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Daxko Operations API
 *
 * description
 *
 * OpenAPI spec version: 0.1.0
 * Contact: support@daxko.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ProgramsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ProgramsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getOfferingDetails
     *
     * Get program offering details
     *
     * @param  string $program_id See /v3/programs/{program_id}/offerings call for how to get program id. (required)
     * @param  string $offering_id See /v3/programs/{program_id}/offerings call for how to get offering id. (required)
     * @param  string $location_id Example: &#39;B1234&#39; would be branch with id 1234.  &#39;S5678&#39; would be site with 5678. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20015
     */
    public function getOfferingDetails($program_id, $offering_id, $location_id)
    {
        list($response) = $this->getOfferingDetailsWithHttpInfo($program_id, $offering_id, $location_id);
        return $response;
    }

    /**
     * Operation getOfferingDetailsWithHttpInfo
     *
     * Get program offering details
     *
     * @param  string $program_id See /v3/programs/{program_id}/offerings call for how to get program id. (required)
     * @param  string $offering_id See /v3/programs/{program_id}/offerings call for how to get offering id. (required)
     * @param  string $location_id Example: &#39;B1234&#39; would be branch with id 1234.  &#39;S5678&#39; would be site with 5678. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20015, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOfferingDetailsWithHttpInfo($program_id, $offering_id, $location_id)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20015';
        $request = $this->getOfferingDetailsRequest($program_id, $offering_id, $location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20015',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOfferingDetailsAsync
     *
     * Get program offering details
     *
     * @param  string $program_id See /v3/programs/{program_id}/offerings call for how to get program id. (required)
     * @param  string $offering_id See /v3/programs/{program_id}/offerings call for how to get offering id. (required)
     * @param  string $location_id Example: &#39;B1234&#39; would be branch with id 1234.  &#39;S5678&#39; would be site with 5678. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOfferingDetailsAsync($program_id, $offering_id, $location_id)
    {
        return $this->getOfferingDetailsAsyncWithHttpInfo($program_id, $offering_id, $location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOfferingDetailsAsyncWithHttpInfo
     *
     * Get program offering details
     *
     * @param  string $program_id See /v3/programs/{program_id}/offerings call for how to get program id. (required)
     * @param  string $offering_id See /v3/programs/{program_id}/offerings call for how to get offering id. (required)
     * @param  string $location_id Example: &#39;B1234&#39; would be branch with id 1234.  &#39;S5678&#39; would be site with 5678. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOfferingDetailsAsyncWithHttpInfo($program_id, $offering_id, $location_id)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20015';
        $request = $this->getOfferingDetailsRequest($program_id, $offering_id, $location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOfferingDetails'
     *
     * @param  string $program_id See /v3/programs/{program_id}/offerings call for how to get program id. (required)
     * @param  string $offering_id See /v3/programs/{program_id}/offerings call for how to get offering id. (required)
     * @param  string $location_id Example: &#39;B1234&#39; would be branch with id 1234.  &#39;S5678&#39; would be site with 5678. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOfferingDetailsRequest($program_id, $offering_id, $location_id)
    {
        // verify the required parameter 'program_id' is set
        if ($program_id === null || (is_array($program_id) && count($program_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $program_id when calling getOfferingDetails'
            );
        }
        // verify the required parameter 'offering_id' is set
        if ($offering_id === null || (is_array($offering_id) && count($offering_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offering_id when calling getOfferingDetails'
            );
        }
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling getOfferingDetails'
            );
        }

        $resourcePath = '/v3/programs/{program_id}/offerings/{offering_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($location_id !== null) {
            $queryParams['location_id'] = ObjectSerializer::toQueryValue($location_id);
        }

        // path params
        if ($program_id !== null) {
            $resourcePath = str_replace(
                '{' . 'program_id' . '}',
                ObjectSerializer::toPathValue($program_id),
                $resourcePath
            );
        }
        // path params
        if ($offering_id !== null) {
            $resourcePath = str_replace(
                '{' . 'offering_id' . '}',
                ObjectSerializer::toPathValue($offering_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProgramCategories
     *
     * List program categories
     *
     * @param  string $as_of Restricts the list of categories to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $location_ids Restricts the list of categories to be associated with programs at the specified locations. If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of categories to only be associated with certain types of program offerings. If omitted, returns categories associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of categories to only be associated with in-house or online program offerings. Default behavior is to return categories for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20016
     */
    public function listProgramCategories($as_of = '{start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between}', $location_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {
        list($response) = $this->listProgramCategoriesWithHttpInfo($as_of, $location_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $date_ranges, $limit);
        return $response;
    }

    /**
     * Operation listProgramCategoriesWithHttpInfo
     *
     * List program categories
     *
     * @param  string $as_of Restricts the list of categories to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $location_ids Restricts the list of categories to be associated with programs at the specified locations. If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of categories to only be associated with certain types of program offerings. If omitted, returns categories associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of categories to only be associated with in-house or online program offerings. Default behavior is to return categories for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20016, HTTP status code, HTTP response headers (array of strings)
     */
    public function listProgramCategoriesWithHttpInfo($as_of = '{start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between}', $location_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20016';
        $request = $this->listProgramCategoriesRequest($as_of, $location_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $date_ranges, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20016',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProgramCategoriesAsync
     *
     * List program categories
     *
     * @param  string $as_of Restricts the list of categories to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $location_ids Restricts the list of categories to be associated with programs at the specified locations. If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of categories to only be associated with certain types of program offerings. If omitted, returns categories associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of categories to only be associated with in-house or online program offerings. Default behavior is to return categories for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProgramCategoriesAsync($as_of = '{start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between}', $location_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {
        return $this->listProgramCategoriesAsyncWithHttpInfo($as_of, $location_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $date_ranges, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProgramCategoriesAsyncWithHttpInfo
     *
     * List program categories
     *
     * @param  string $as_of Restricts the list of categories to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $location_ids Restricts the list of categories to be associated with programs at the specified locations. If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of categories to only be associated with certain types of program offerings. If omitted, returns categories associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of categories to only be associated with in-house or online program offerings. Default behavior is to return categories for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProgramCategoriesAsyncWithHttpInfo($as_of = '{start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between}', $location_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20016';
        $request = $this->listProgramCategoriesRequest($as_of, $location_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $date_ranges, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProgramCategories'
     *
     * @param  string $as_of Restricts the list of categories to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $location_ids Restricts the list of categories to be associated with programs at the specified locations. If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of categories to only be associated with certain types of program offerings. If omitted, returns categories associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of categories to only be associated with in-house or online program offerings. Default behavior is to return categories for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listProgramCategoriesRequest($as_of = '{start:<datetime for request>,end:<datetime of request>,mode:registration_occurs_between}', $location_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {

        $resourcePath = '/v3/programs/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($as_of !== null) {
            $queryParams['as_of'] = ObjectSerializer::toQueryValue($as_of);
        }
        // query params
        if (is_array($location_ids)) {
            $location_ids = ObjectSerializer::serializeCollection($location_ids, 'csv', true);
        }
        if ($location_ids !== null) {
            $queryParams['location_ids'] = ObjectSerializer::toQueryValue($location_ids);
        }
        // query params
        if (is_array($offering_types)) {
            $offering_types = ObjectSerializer::serializeCollection($offering_types, 'csv', true);
        }
        if ($offering_types !== null) {
            $queryParams['offering_types'] = ObjectSerializer::toQueryValue($offering_types);
        }
        // query params
        if ($registration_type !== null) {
            $queryParams['registration_type'] = ObjectSerializer::toQueryValue($registration_type);
        }
        // query params
        if ($include_inactive_categories !== null) {
            $queryParams['include_inactive_categories'] = ObjectSerializer::toQueryValue($include_inactive_categories);
        }
        // query params
        if ($include_inactive_locations !== null) {
            $queryParams['include_inactive_locations'] = ObjectSerializer::toQueryValue($include_inactive_locations);
        }
        // query params
        if ($date_ranges !== null) {
            $queryParams['date_ranges'] = ObjectSerializer::toQueryValue($date_ranges);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProgramLocations
     *
     * List program locations
     *
     * @param  string $as_of Restricts the list of locations to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $category_ids Restricts the list of locations to be associated with programs that offers programs with the specified categories. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of locations to only be associated with certain types of program offerings. If omitted, returns locations associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of locations to only be associated with in-house or online program offerings. Default behavior is to return locations for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show locations associated with inactive categories. Default behavior will omit locations associated with inactive categories. However, if an offering has an inactive category and at least one active category, its location will be returned. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show inactive locations. Default behavior will omit inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20017
     */
    public function listProgramLocations($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {
        list($response) = $this->listProgramLocationsWithHttpInfo($as_of, $category_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $date_ranges, $limit);
        return $response;
    }

    /**
     * Operation listProgramLocationsWithHttpInfo
     *
     * List program locations
     *
     * @param  string $as_of Restricts the list of locations to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $category_ids Restricts the list of locations to be associated with programs that offers programs with the specified categories. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of locations to only be associated with certain types of program offerings. If omitted, returns locations associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of locations to only be associated with in-house or online program offerings. Default behavior is to return locations for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show locations associated with inactive categories. Default behavior will omit locations associated with inactive categories. However, if an offering has an inactive category and at least one active category, its location will be returned. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show inactive locations. Default behavior will omit inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20017, HTTP status code, HTTP response headers (array of strings)
     */
    public function listProgramLocationsWithHttpInfo($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20017';
        $request = $this->listProgramLocationsRequest($as_of, $category_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $date_ranges, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20017',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProgramLocationsAsync
     *
     * List program locations
     *
     * @param  string $as_of Restricts the list of locations to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $category_ids Restricts the list of locations to be associated with programs that offers programs with the specified categories. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of locations to only be associated with certain types of program offerings. If omitted, returns locations associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of locations to only be associated with in-house or online program offerings. Default behavior is to return locations for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show locations associated with inactive categories. Default behavior will omit locations associated with inactive categories. However, if an offering has an inactive category and at least one active category, its location will be returned. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show inactive locations. Default behavior will omit inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProgramLocationsAsync($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {
        return $this->listProgramLocationsAsyncWithHttpInfo($as_of, $category_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $date_ranges, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProgramLocationsAsyncWithHttpInfo
     *
     * List program locations
     *
     * @param  string $as_of Restricts the list of locations to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $category_ids Restricts the list of locations to be associated with programs that offers programs with the specified categories. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of locations to only be associated with certain types of program offerings. If omitted, returns locations associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of locations to only be associated with in-house or online program offerings. Default behavior is to return locations for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show locations associated with inactive categories. Default behavior will omit locations associated with inactive categories. However, if an offering has an inactive category and at least one active category, its location will be returned. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show inactive locations. Default behavior will omit inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProgramLocationsAsyncWithHttpInfo($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20017';
        $request = $this->listProgramLocationsRequest($as_of, $category_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $date_ranges, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProgramLocations'
     *
     * @param  string $as_of Restricts the list of locations to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges.  See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string[] $category_ids Restricts the list of locations to be associated with programs that offers programs with the specified categories. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the list of locations to only be associated with certain types of program offerings. If omitted, returns locations associated with all types of program offerings. (optional)
     * @param  string $registration_type Restricts the list of locations to only be associated with in-house or online program offerings. Default behavior is to return locations for both in-house and online program offerings. (optional)
     * @param  bool $include_inactive_categories Indicates whether to show locations associated with inactive categories. Default behavior will omit locations associated with inactive categories. However, if an offering has an inactive category and at least one active category, its location will be returned. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show inactive locations. Default behavior will omit inactive locations. (optional, default to false)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  int $limit Number of results to return. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listProgramLocationsRequest($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $offering_types = null, $registration_type = null, $include_inactive_categories = 'false', $include_inactive_locations = 'false', $date_ranges = null, $limit = '100')
    {

        $resourcePath = '/v3/programs/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($as_of !== null) {
            $queryParams['as_of'] = ObjectSerializer::toQueryValue($as_of);
        }
        // query params
        if (is_array($category_ids)) {
            $category_ids = ObjectSerializer::serializeCollection($category_ids, 'csv', true);
        }
        if ($category_ids !== null) {
            $queryParams['category_ids'] = ObjectSerializer::toQueryValue($category_ids);
        }
        // query params
        if (is_array($offering_types)) {
            $offering_types = ObjectSerializer::serializeCollection($offering_types, 'csv', true);
        }
        if ($offering_types !== null) {
            $queryParams['offering_types'] = ObjectSerializer::toQueryValue($offering_types);
        }
        // query params
        if ($registration_type !== null) {
            $queryParams['registration_type'] = ObjectSerializer::toQueryValue($registration_type);
        }
        // query params
        if ($include_inactive_categories !== null) {
            $queryParams['include_inactive_categories'] = ObjectSerializer::toQueryValue($include_inactive_categories);
        }
        // query params
        if ($include_inactive_locations !== null) {
            $queryParams['include_inactive_locations'] = ObjectSerializer::toQueryValue($include_inactive_locations);
        }
        // query params
        if ($date_ranges !== null) {
            $queryParams['date_ranges'] = ObjectSerializer::toQueryValue($date_ranges);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProgramOfferings
     *
     * Get list of offerings for particular program
     *
     * @param  string $program_id See description above for examples of program ids. (required)
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $category_ids Comma delimited list of category ids to filter by.  Example: &#39;TAG1234&#39; is programs tag with id 1234, &#39;CAT5678&#39; is a child care/camp category with id 5678 (optional)
     * @param  string $location_ids Comma delimited list of location ids to filter by.  Example: &#39;B1234&#39; is branch with id 1234.  &#39;S5678&#39; is site with id 5678. (optional)
     * @param  string $registration_type Filters results that are currently open for registration. (optional, default to online)
     * @param  string $offering_ids Comma delimited list of offering ids to filter by. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20014
     */
    public function listProgramOfferings($program_id, $as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $location_ids = null, $registration_type = 'online', $offering_ids = null)
    {
        list($response) = $this->listProgramOfferingsWithHttpInfo($program_id, $as_of, $category_ids, $location_ids, $registration_type, $offering_ids);
        return $response;
    }

    /**
     * Operation listProgramOfferingsWithHttpInfo
     *
     * Get list of offerings for particular program
     *
     * @param  string $program_id See description above for examples of program ids. (required)
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $category_ids Comma delimited list of category ids to filter by.  Example: &#39;TAG1234&#39; is programs tag with id 1234, &#39;CAT5678&#39; is a child care/camp category with id 5678 (optional)
     * @param  string $location_ids Comma delimited list of location ids to filter by.  Example: &#39;B1234&#39; is branch with id 1234.  &#39;S5678&#39; is site with id 5678. (optional)
     * @param  string $registration_type Filters results that are currently open for registration. (optional, default to online)
     * @param  string $offering_ids Comma delimited list of offering ids to filter by. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20014, HTTP status code, HTTP response headers (array of strings)
     */
    public function listProgramOfferingsWithHttpInfo($program_id, $as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $location_ids = null, $registration_type = 'online', $offering_ids = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20014';
        $request = $this->listProgramOfferingsRequest($program_id, $as_of, $category_ids, $location_ids, $registration_type, $offering_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20014',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProgramOfferingsAsync
     *
     * Get list of offerings for particular program
     *
     * @param  string $program_id See description above for examples of program ids. (required)
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $category_ids Comma delimited list of category ids to filter by.  Example: &#39;TAG1234&#39; is programs tag with id 1234, &#39;CAT5678&#39; is a child care/camp category with id 5678 (optional)
     * @param  string $location_ids Comma delimited list of location ids to filter by.  Example: &#39;B1234&#39; is branch with id 1234.  &#39;S5678&#39; is site with id 5678. (optional)
     * @param  string $registration_type Filters results that are currently open for registration. (optional, default to online)
     * @param  string $offering_ids Comma delimited list of offering ids to filter by. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProgramOfferingsAsync($program_id, $as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $location_ids = null, $registration_type = 'online', $offering_ids = null)
    {
        return $this->listProgramOfferingsAsyncWithHttpInfo($program_id, $as_of, $category_ids, $location_ids, $registration_type, $offering_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProgramOfferingsAsyncWithHttpInfo
     *
     * Get list of offerings for particular program
     *
     * @param  string $program_id See description above for examples of program ids. (required)
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $category_ids Comma delimited list of category ids to filter by.  Example: &#39;TAG1234&#39; is programs tag with id 1234, &#39;CAT5678&#39; is a child care/camp category with id 5678 (optional)
     * @param  string $location_ids Comma delimited list of location ids to filter by.  Example: &#39;B1234&#39; is branch with id 1234.  &#39;S5678&#39; is site with id 5678. (optional)
     * @param  string $registration_type Filters results that are currently open for registration. (optional, default to online)
     * @param  string $offering_ids Comma delimited list of offering ids to filter by. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProgramOfferingsAsyncWithHttpInfo($program_id, $as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $location_ids = null, $registration_type = 'online', $offering_ids = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20014';
        $request = $this->listProgramOfferingsRequest($program_id, $as_of, $category_ids, $location_ids, $registration_type, $offering_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProgramOfferings'
     *
     * @param  string $program_id See description above for examples of program ids. (required)
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial]({{sitedir}}/tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $category_ids Comma delimited list of category ids to filter by.  Example: &#39;TAG1234&#39; is programs tag with id 1234, &#39;CAT5678&#39; is a child care/camp category with id 5678 (optional)
     * @param  string $location_ids Comma delimited list of location ids to filter by.  Example: &#39;B1234&#39; is branch with id 1234.  &#39;S5678&#39; is site with id 5678. (optional)
     * @param  string $registration_type Filters results that are currently open for registration. (optional, default to online)
     * @param  string $offering_ids Comma delimited list of offering ids to filter by. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listProgramOfferingsRequest($program_id, $as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $category_ids = null, $location_ids = null, $registration_type = 'online', $offering_ids = null)
    {
        // verify the required parameter 'program_id' is set
        if ($program_id === null || (is_array($program_id) && count($program_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $program_id when calling listProgramOfferings'
            );
        }

        $resourcePath = '/v3/programs/{program_id}/offerings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($as_of !== null) {
            $queryParams['as_of'] = ObjectSerializer::toQueryValue($as_of);
        }
        // query params
        if ($category_ids !== null) {
            $queryParams['category_ids'] = ObjectSerializer::toQueryValue($category_ids);
        }
        // query params
        if ($location_ids !== null) {
            $queryParams['location_ids'] = ObjectSerializer::toQueryValue($location_ids);
        }
        // query params
        if ($registration_type !== null) {
            $queryParams['registration_type'] = ObjectSerializer::toQueryValue($registration_type);
        }
        // query params
        if ($offering_ids !== null) {
            $queryParams['offering_ids'] = ObjectSerializer::toQueryValue($offering_ids);
        }

        // path params
        if ($program_id !== null) {
            $resourcePath = str_replace(
                '{' . 'program_id' . '}',
                ObjectSerializer::toPathValue($program_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchProgramOfferings
     *
     * Search program offerings
     *
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial](../tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $keywords Keywords for performing full text search.  The following fields are searched: offering name, offering description, program name, program description, category name, instructor name, contact name. (optional)
     * @param  string[] $location_ids Restricts the results to comma delimited list of locations . If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $category_ids Restricts the results to comma delimited list of categories.  If omitted, no category based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the results to only be associated with certain types of program\\ offerings. If omitted, returns offerings associated with all types of \\ program offerings.  |Program Offering Type|Filter Value| |-|-| |Standard|session| |Package|package| |Childcare|rate_plan| |Camp|camp_instance| (optional)
     * @param  string $registration_type Restricts the list of offerings to only in-house or online program offerings. Default behavior is to return both in-house and online program offerings. (optional, default to online)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $days_offered Restricts results to be match at least 1 of the days as the query parameter.  The &#x60;score&#x60; on each individual result will be higher if more days match.  NOTE: If the source offering in Daxko Operations does not have days offered defined, then those results will always be returned, but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $time_ranges Restricts results to match at least 1 of the specified start time ranges.  NOTE: If the source offering in Daxko Operations does not have a time defined, then those results will always be returned but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  string $birth_dates Restricts results based on comma-delimited list of birth dates.  At least one of the birth dates in the collection must be eligible for the offering based on the offering set up in Daxko Operations. (optional)
     * @param  bool $include_facets Controls whether facets (statistics) of the current search are returned.  This controls whether the &#x60;facets&#x60; property is returned. (optional, default to false)
     * @param  string $time_range_facets If &#x60;include_facets&#x60; query parameter is true, this allows customization of what ranges are returned in &#x60;facets.time_ranges&#x60;. (optional)
     * @param  int $limit Number of offering results to return (max of 100).  If you set to 0 and set &#x60;include_facets&#x60; to true, you can still get the facet results without the individual offering results. (optional, default to 100)
     * @param  string[] $sort Determines how the offering results will be sorted. By default, the sorting will be by score (descending order). For more information on sorting options, see the Sorting section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#sorting) for more information. All fields correspond to the fields described in the response body.  The supported fields and their default sort orders for this API call are  |Field|Default sort order| |-|-| |score|descending| |name|ascending| |start_date|ascending| (optional)
     * @param  string[] $program_id Restricts the results to comma-delimited list of program ids. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string $after This parameter is used as a cursor to fetch the next page of results. Use the &#x60;after&#x60; value from a previously returned response body, or, use the URL link returned in the &#x60;links&#x60; response value to avoid having to construct your own URL. View the Paging section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#pagination) for more information. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20013
     */
    public function searchProgramOfferings($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $keywords = null, $location_ids = null, $category_ids = null, $offering_types = null, $registration_type = 'online', $include_inactive_categories = 'false', $include_inactive_locations = 'false', $days_offered = null, $time_ranges = null, $date_ranges = null, $birth_dates = null, $include_facets = 'false', $time_range_facets = null, $limit = '100', $sort = null, $program_id = null, $after = null)
    {
        list($response) = $this->searchProgramOfferingsWithHttpInfo($as_of, $keywords, $location_ids, $category_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $days_offered, $time_ranges, $date_ranges, $birth_dates, $include_facets, $time_range_facets, $limit, $sort, $program_id, $after);
        return $response;
    }

    /**
     * Operation searchProgramOfferingsWithHttpInfo
     *
     * Search program offerings
     *
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial](../tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $keywords Keywords for performing full text search.  The following fields are searched: offering name, offering description, program name, program description, category name, instructor name, contact name. (optional)
     * @param  string[] $location_ids Restricts the results to comma delimited list of locations . If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $category_ids Restricts the results to comma delimited list of categories.  If omitted, no category based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the results to only be associated with certain types of program\\ offerings. If omitted, returns offerings associated with all types of \\ program offerings.  |Program Offering Type|Filter Value| |-|-| |Standard|session| |Package|package| |Childcare|rate_plan| |Camp|camp_instance| (optional)
     * @param  string $registration_type Restricts the list of offerings to only in-house or online program offerings. Default behavior is to return both in-house and online program offerings. (optional, default to online)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $days_offered Restricts results to be match at least 1 of the days as the query parameter.  The &#x60;score&#x60; on each individual result will be higher if more days match.  NOTE: If the source offering in Daxko Operations does not have days offered defined, then those results will always be returned, but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $time_ranges Restricts results to match at least 1 of the specified start time ranges.  NOTE: If the source offering in Daxko Operations does not have a time defined, then those results will always be returned but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  string $birth_dates Restricts results based on comma-delimited list of birth dates.  At least one of the birth dates in the collection must be eligible for the offering based on the offering set up in Daxko Operations. (optional)
     * @param  bool $include_facets Controls whether facets (statistics) of the current search are returned.  This controls whether the &#x60;facets&#x60; property is returned. (optional, default to false)
     * @param  string $time_range_facets If &#x60;include_facets&#x60; query parameter is true, this allows customization of what ranges are returned in &#x60;facets.time_ranges&#x60;. (optional)
     * @param  int $limit Number of offering results to return (max of 100).  If you set to 0 and set &#x60;include_facets&#x60; to true, you can still get the facet results without the individual offering results. (optional, default to 100)
     * @param  string[] $sort Determines how the offering results will be sorted. By default, the sorting will be by score (descending order). For more information on sorting options, see the Sorting section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#sorting) for more information. All fields correspond to the fields described in the response body.  The supported fields and their default sort orders for this API call are  |Field|Default sort order| |-|-| |score|descending| |name|ascending| |start_date|ascending| (optional)
     * @param  string[] $program_id Restricts the results to comma-delimited list of program ids. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string $after This parameter is used as a cursor to fetch the next page of results. Use the &#x60;after&#x60; value from a previously returned response body, or, use the URL link returned in the &#x60;links&#x60; response value to avoid having to construct your own URL. View the Paging section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#pagination) for more information. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchProgramOfferingsWithHttpInfo($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $keywords = null, $location_ids = null, $category_ids = null, $offering_types = null, $registration_type = 'online', $include_inactive_categories = 'false', $include_inactive_locations = 'false', $days_offered = null, $time_ranges = null, $date_ranges = null, $birth_dates = null, $include_facets = 'false', $time_range_facets = null, $limit = '100', $sort = null, $program_id = null, $after = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20013';
        $request = $this->searchProgramOfferingsRequest($as_of, $keywords, $location_ids, $category_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $days_offered, $time_ranges, $date_ranges, $birth_dates, $include_facets, $time_range_facets, $limit, $sort, $program_id, $after);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchProgramOfferingsAsync
     *
     * Search program offerings
     *
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial](../tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $keywords Keywords for performing full text search.  The following fields are searched: offering name, offering description, program name, program description, category name, instructor name, contact name. (optional)
     * @param  string[] $location_ids Restricts the results to comma delimited list of locations . If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $category_ids Restricts the results to comma delimited list of categories.  If omitted, no category based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the results to only be associated with certain types of program\\ offerings. If omitted, returns offerings associated with all types of \\ program offerings.  |Program Offering Type|Filter Value| |-|-| |Standard|session| |Package|package| |Childcare|rate_plan| |Camp|camp_instance| (optional)
     * @param  string $registration_type Restricts the list of offerings to only in-house or online program offerings. Default behavior is to return both in-house and online program offerings. (optional, default to online)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $days_offered Restricts results to be match at least 1 of the days as the query parameter.  The &#x60;score&#x60; on each individual result will be higher if more days match.  NOTE: If the source offering in Daxko Operations does not have days offered defined, then those results will always be returned, but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $time_ranges Restricts results to match at least 1 of the specified start time ranges.  NOTE: If the source offering in Daxko Operations does not have a time defined, then those results will always be returned but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  string $birth_dates Restricts results based on comma-delimited list of birth dates.  At least one of the birth dates in the collection must be eligible for the offering based on the offering set up in Daxko Operations. (optional)
     * @param  bool $include_facets Controls whether facets (statistics) of the current search are returned.  This controls whether the &#x60;facets&#x60; property is returned. (optional, default to false)
     * @param  string $time_range_facets If &#x60;include_facets&#x60; query parameter is true, this allows customization of what ranges are returned in &#x60;facets.time_ranges&#x60;. (optional)
     * @param  int $limit Number of offering results to return (max of 100).  If you set to 0 and set &#x60;include_facets&#x60; to true, you can still get the facet results without the individual offering results. (optional, default to 100)
     * @param  string[] $sort Determines how the offering results will be sorted. By default, the sorting will be by score (descending order). For more information on sorting options, see the Sorting section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#sorting) for more information. All fields correspond to the fields described in the response body.  The supported fields and their default sort orders for this API call are  |Field|Default sort order| |-|-| |score|descending| |name|ascending| |start_date|ascending| (optional)
     * @param  string[] $program_id Restricts the results to comma-delimited list of program ids. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string $after This parameter is used as a cursor to fetch the next page of results. Use the &#x60;after&#x60; value from a previously returned response body, or, use the URL link returned in the &#x60;links&#x60; response value to avoid having to construct your own URL. View the Paging section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#pagination) for more information. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchProgramOfferingsAsync($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $keywords = null, $location_ids = null, $category_ids = null, $offering_types = null, $registration_type = 'online', $include_inactive_categories = 'false', $include_inactive_locations = 'false', $days_offered = null, $time_ranges = null, $date_ranges = null, $birth_dates = null, $include_facets = 'false', $time_range_facets = null, $limit = '100', $sort = null, $program_id = null, $after = null)
    {
        return $this->searchProgramOfferingsAsyncWithHttpInfo($as_of, $keywords, $location_ids, $category_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $days_offered, $time_ranges, $date_ranges, $birth_dates, $include_facets, $time_range_facets, $limit, $sort, $program_id, $after)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchProgramOfferingsAsyncWithHttpInfo
     *
     * Search program offerings
     *
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial](../tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $keywords Keywords for performing full text search.  The following fields are searched: offering name, offering description, program name, program description, category name, instructor name, contact name. (optional)
     * @param  string[] $location_ids Restricts the results to comma delimited list of locations . If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $category_ids Restricts the results to comma delimited list of categories.  If omitted, no category based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the results to only be associated with certain types of program\\ offerings. If omitted, returns offerings associated with all types of \\ program offerings.  |Program Offering Type|Filter Value| |-|-| |Standard|session| |Package|package| |Childcare|rate_plan| |Camp|camp_instance| (optional)
     * @param  string $registration_type Restricts the list of offerings to only in-house or online program offerings. Default behavior is to return both in-house and online program offerings. (optional, default to online)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $days_offered Restricts results to be match at least 1 of the days as the query parameter.  The &#x60;score&#x60; on each individual result will be higher if more days match.  NOTE: If the source offering in Daxko Operations does not have days offered defined, then those results will always be returned, but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $time_ranges Restricts results to match at least 1 of the specified start time ranges.  NOTE: If the source offering in Daxko Operations does not have a time defined, then those results will always be returned but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  string $birth_dates Restricts results based on comma-delimited list of birth dates.  At least one of the birth dates in the collection must be eligible for the offering based on the offering set up in Daxko Operations. (optional)
     * @param  bool $include_facets Controls whether facets (statistics) of the current search are returned.  This controls whether the &#x60;facets&#x60; property is returned. (optional, default to false)
     * @param  string $time_range_facets If &#x60;include_facets&#x60; query parameter is true, this allows customization of what ranges are returned in &#x60;facets.time_ranges&#x60;. (optional)
     * @param  int $limit Number of offering results to return (max of 100).  If you set to 0 and set &#x60;include_facets&#x60; to true, you can still get the facet results without the individual offering results. (optional, default to 100)
     * @param  string[] $sort Determines how the offering results will be sorted. By default, the sorting will be by score (descending order). For more information on sorting options, see the Sorting section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#sorting) for more information. All fields correspond to the fields described in the response body.  The supported fields and their default sort orders for this API call are  |Field|Default sort order| |-|-| |score|descending| |name|ascending| |start_date|ascending| (optional)
     * @param  string[] $program_id Restricts the results to comma-delimited list of program ids. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string $after This parameter is used as a cursor to fetch the next page of results. Use the &#x60;after&#x60; value from a previously returned response body, or, use the URL link returned in the &#x60;links&#x60; response value to avoid having to construct your own URL. View the Paging section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#pagination) for more information. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchProgramOfferingsAsyncWithHttpInfo($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $keywords = null, $location_ids = null, $category_ids = null, $offering_types = null, $registration_type = 'online', $include_inactive_categories = 'false', $include_inactive_locations = 'false', $days_offered = null, $time_ranges = null, $date_ranges = null, $birth_dates = null, $include_facets = 'false', $time_range_facets = null, $limit = '100', $sort = null, $program_id = null, $after = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20013';
        $request = $this->searchProgramOfferingsRequest($as_of, $keywords, $location_ids, $category_ids, $offering_types, $registration_type, $include_inactive_categories, $include_inactive_locations, $days_offered, $time_ranges, $date_ranges, $birth_dates, $include_facets, $time_range_facets, $limit, $sort, $program_id, $after);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchProgramOfferings'
     *
     * @param  string $as_of Restricts results to have the specified &#x60;start&#x60; and &#x60;end&#x60; datetime in at least one of the registration datetime ranges. See [As of date tutorial](../tutorials/as_of_date/index.html). (optional, default to {start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between})
     * @param  string $keywords Keywords for performing full text search.  The following fields are searched: offering name, offering description, program name, program description, category name, instructor name, contact name. (optional)
     * @param  string[] $location_ids Restricts the results to comma delimited list of locations . If omitted, no location-based restrictions will be applied. (optional)
     * @param  string[] $category_ids Restricts the results to comma delimited list of categories.  If omitted, no category based restrictions will be applied. (optional)
     * @param  string[] $offering_types Restricts the results to only be associated with certain types of program\\ offerings. If omitted, returns offerings associated with all types of \\ program offerings.  |Program Offering Type|Filter Value| |-|-| |Standard|session| |Package|package| |Childcare|rate_plan| |Camp|camp_instance| (optional)
     * @param  string $registration_type Restricts the list of offerings to only in-house or online program offerings. Default behavior is to return both in-house and online program offerings. (optional, default to online)
     * @param  bool $include_inactive_categories Indicates whether to show inactive categories. Default behavior will omit inactive categories. (optional, default to false)
     * @param  bool $include_inactive_locations Indicates whether to show categories associated with inactive locations. Defaultbehavior will omit categories associated with inactive locations. (optional, default to false)
     * @param  string $days_offered Restricts results to be match at least 1 of the days as the query parameter.  The &#x60;score&#x60; on each individual result will be higher if more days match.  NOTE: If the source offering in Daxko Operations does not have days offered defined, then those results will always be returned, but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $time_ranges Restricts results to match at least 1 of the specified start time ranges.  NOTE: If the source offering in Daxko Operations does not have a time defined, then those results will always be returned but the &#x60;score&#x60; will be lower. (optional)
     * @param  string $date_ranges Restricts results that occur within at least one of the date ranges. (optional)
     * @param  string $birth_dates Restricts results based on comma-delimited list of birth dates.  At least one of the birth dates in the collection must be eligible for the offering based on the offering set up in Daxko Operations. (optional)
     * @param  bool $include_facets Controls whether facets (statistics) of the current search are returned.  This controls whether the &#x60;facets&#x60; property is returned. (optional, default to false)
     * @param  string $time_range_facets If &#x60;include_facets&#x60; query parameter is true, this allows customization of what ranges are returned in &#x60;facets.time_ranges&#x60;. (optional)
     * @param  int $limit Number of offering results to return (max of 100).  If you set to 0 and set &#x60;include_facets&#x60; to true, you can still get the facet results without the individual offering results. (optional, default to 100)
     * @param  string[] $sort Determines how the offering results will be sorted. By default, the sorting will be by score (descending order). For more information on sorting options, see the Sorting section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#sorting) for more information. All fields correspond to the fields described in the response body.  The supported fields and their default sort orders for this API call are  |Field|Default sort order| |-|-| |score|descending| |name|ascending| |start_date|ascending| (optional)
     * @param  string[] $program_id Restricts the results to comma-delimited list of program ids. If omitted, no category-based restrictions will be applied. (optional)
     * @param  string $after This parameter is used as a cursor to fetch the next page of results. Use the &#x60;after&#x60; value from a previously returned response body, or, use the URL link returned in the &#x60;links&#x60; response value to avoid having to construct your own URL. View the Paging section of the [Getting Started Tutorial](../tutorials/getting_started/index.html#pagination) for more information. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchProgramOfferingsRequest($as_of = '{start:<datetime of request>,end:<datetime of request>,mode:registration_occurs_between}', $keywords = null, $location_ids = null, $category_ids = null, $offering_types = null, $registration_type = 'online', $include_inactive_categories = 'false', $include_inactive_locations = 'false', $days_offered = null, $time_ranges = null, $date_ranges = null, $birth_dates = null, $include_facets = 'false', $time_range_facets = null, $limit = '100', $sort = null, $program_id = null, $after = null)
    {

        $resourcePath = '/v3/programs/offerings/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($as_of !== null) {
            $queryParams['as_of'] = ObjectSerializer::toQueryValue($as_of);
        }
        // query params
        if ($keywords !== null) {
            $queryParams['keywords'] = ObjectSerializer::toQueryValue($keywords);
        }
        // query params
        if (is_array($location_ids)) {
            $location_ids = ObjectSerializer::serializeCollection($location_ids, 'csv', true);
        }
        if ($location_ids !== null) {
            $queryParams['location_ids'] = ObjectSerializer::toQueryValue($location_ids);
        }
        // query params
        if (is_array($category_ids)) {
            $category_ids = ObjectSerializer::serializeCollection($category_ids, 'csv', true);
        }
        if ($category_ids !== null) {
            $queryParams['category_ids'] = ObjectSerializer::toQueryValue($category_ids);
        }
        // query params
        if (is_array($offering_types)) {
            $offering_types = ObjectSerializer::serializeCollection($offering_types, 'csv', true);
        }
        if ($offering_types !== null) {
            $queryParams['offering_types'] = ObjectSerializer::toQueryValue($offering_types);
        }
        // query params
        if ($registration_type !== null) {
            $queryParams['registration_type'] = ObjectSerializer::toQueryValue($registration_type);
        }
        // query params
        if ($include_inactive_categories !== null) {
            $queryParams['include_inactive_categories'] = ObjectSerializer::toQueryValue($include_inactive_categories);
        }
        // query params
        if ($include_inactive_locations !== null) {
            $queryParams['include_inactive_locations'] = ObjectSerializer::toQueryValue($include_inactive_locations);
        }
        // query params
        if ($days_offered !== null) {
            $queryParams['days_offered'] = ObjectSerializer::toQueryValue($days_offered);
        }
        // query params
        if ($time_ranges !== null) {
            $queryParams['time_ranges'] = ObjectSerializer::toQueryValue($time_ranges);
        }
        // query params
        if ($date_ranges !== null) {
            $queryParams['date_ranges'] = ObjectSerializer::toQueryValue($date_ranges);
        }
        // query params
        if ($birth_dates !== null) {
            $queryParams['birth_dates'] = ObjectSerializer::toQueryValue($birth_dates);
        }
        // query params
        if ($include_facets !== null) {
            $queryParams['include_facets'] = ObjectSerializer::toQueryValue($include_facets);
        }
        // query params
        if ($time_range_facets !== null) {
            $queryParams['time_range_facets'] = ObjectSerializer::toQueryValue($time_range_facets);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if (is_array($sort)) {
            $sort = ObjectSerializer::serializeCollection($sort, 'csv', true);
        }
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if (is_array($program_id)) {
            $program_id = ObjectSerializer::serializeCollection($program_id, 'csv', true);
        }
        if ($program_id !== null) {
            $queryParams['program_id'] = ObjectSerializer::toQueryValue($program_id);
        }
        // query params
        if ($after !== null) {
            $queryParams['after'] = ObjectSerializer::toQueryValue($after);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
