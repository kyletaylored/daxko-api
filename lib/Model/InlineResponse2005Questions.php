<?php
/**
 * InlineResponse2005Questions
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Daxko Operations API
 *
 * description
 *
 * OpenAPI spec version: 0.1.0
 * Contact: support@daxko.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * InlineResponse2005Questions Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class InlineResponse2005Questions implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'inline_response_200_5_questions';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'type' => 'string',
        'title' => 'string',
        'description' => 'string',
        'required' => 'bool',
        'read_only' => 'bool',
        'max_length' => 'float',
        'default_value' => 'string',
        'possible_answers' => '\Swagger\Client\Model\InlineResponse2005PossibleAnswers[]',
        'hide_empty_option' => 'bool',
        'empty_value' => 'string',
        'pattern' => 'string',
        'show_extension' => 'bool',
        'intl' => 'bool',
        'show_first' => 'bool',
        'show_middle' => 'bool',
        'show_last' => 'bool',
        'show_prefix' => 'bool',
        'show_suffix' => 'bool',
        'required_first' => 'bool',
        'required_middle' => 'bool',
        'required_last' => 'bool',
        'prefixes' => '\Swagger\Client\Model\InlineResponse2005Prefixes[]',
        'suffixes' => '\Swagger\Client\Model\InlineResponse2005Suffixes[]',
        'ca_provinces' => '\Swagger\Client\Model\InlineResponse2005CaProvinces[]',
        'countries' => '\Swagger\Client\Model\InlineResponse2005Countries[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'type' => null,
        'title' => null,
        'description' => null,
        'required' => null,
        'read_only' => null,
        'max_length' => null,
        'default_value' => null,
        'possible_answers' => null,
        'hide_empty_option' => null,
        'empty_value' => null,
        'pattern' => null,
        'show_extension' => null,
        'intl' => null,
        'show_first' => null,
        'show_middle' => null,
        'show_last' => null,
        'show_prefix' => null,
        'show_suffix' => null,
        'required_first' => null,
        'required_middle' => null,
        'required_last' => null,
        'prefixes' => null,
        'suffixes' => null,
        'ca_provinces' => null,
        'countries' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'type' => 'type',
        'title' => 'title',
        'description' => 'description',
        'required' => 'required',
        'read_only' => 'read_only',
        'max_length' => 'max_length',
        'default_value' => 'default_value',
        'possible_answers' => 'possible_answers',
        'hide_empty_option' => 'hide_empty_option',
        'empty_value' => 'empty_value',
        'pattern' => 'pattern',
        'show_extension' => 'show_extension',
        'intl' => 'intl',
        'show_first' => 'show_first',
        'show_middle' => 'show_middle',
        'show_last' => 'show_last',
        'show_prefix' => 'show_prefix',
        'show_suffix' => 'show_suffix',
        'required_first' => 'required_first',
        'required_middle' => 'required_middle',
        'required_last' => 'required_last',
        'prefixes' => 'prefixes',
        'suffixes' => 'suffixes',
        'ca_provinces' => 'ca_provinces',
        'countries' => 'countries'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'type' => 'setType',
        'title' => 'setTitle',
        'description' => 'setDescription',
        'required' => 'setRequired',
        'read_only' => 'setReadOnly',
        'max_length' => 'setMaxLength',
        'default_value' => 'setDefaultValue',
        'possible_answers' => 'setPossibleAnswers',
        'hide_empty_option' => 'setHideEmptyOption',
        'empty_value' => 'setEmptyValue',
        'pattern' => 'setPattern',
        'show_extension' => 'setShowExtension',
        'intl' => 'setIntl',
        'show_first' => 'setShowFirst',
        'show_middle' => 'setShowMiddle',
        'show_last' => 'setShowLast',
        'show_prefix' => 'setShowPrefix',
        'show_suffix' => 'setShowSuffix',
        'required_first' => 'setRequiredFirst',
        'required_middle' => 'setRequiredMiddle',
        'required_last' => 'setRequiredLast',
        'prefixes' => 'setPrefixes',
        'suffixes' => 'setSuffixes',
        'ca_provinces' => 'setCaProvinces',
        'countries' => 'setCountries'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'type' => 'getType',
        'title' => 'getTitle',
        'description' => 'getDescription',
        'required' => 'getRequired',
        'read_only' => 'getReadOnly',
        'max_length' => 'getMaxLength',
        'default_value' => 'getDefaultValue',
        'possible_answers' => 'getPossibleAnswers',
        'hide_empty_option' => 'getHideEmptyOption',
        'empty_value' => 'getEmptyValue',
        'pattern' => 'getPattern',
        'show_extension' => 'getShowExtension',
        'intl' => 'getIntl',
        'show_first' => 'getShowFirst',
        'show_middle' => 'getShowMiddle',
        'show_last' => 'getShowLast',
        'show_prefix' => 'getShowPrefix',
        'show_suffix' => 'getShowSuffix',
        'required_first' => 'getRequiredFirst',
        'required_middle' => 'getRequiredMiddle',
        'required_last' => 'getRequiredLast',
        'prefixes' => 'getPrefixes',
        'suffixes' => 'getSuffixes',
        'ca_provinces' => 'getCaProvinces',
        'countries' => 'getCountries'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const TYPE_SECTION = 'section';
    const TYPE_TEXT = 'text';
    const TYPE_NAME = 'name';
    const TYPE_DATE = 'date';
    const TYPE_DROPDOWN = 'dropdown';
    const TYPE_RADIO = 'radio';
    const TYPE_CHECKBOXES = 'checkboxes';
    const TYPE_PHONE = 'phone';
    const TYPE_ADDRESS = 'address';
    const TYPE_EMAIL = 'email';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_SECTION,
            self::TYPE_TEXT,
            self::TYPE_NAME,
            self::TYPE_DATE,
            self::TYPE_DROPDOWN,
            self::TYPE_RADIO,
            self::TYPE_CHECKBOXES,
            self::TYPE_PHONE,
            self::TYPE_ADDRESS,
            self::TYPE_EMAIL,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;
        $this->container['title'] = isset($data['title']) ? $data['title'] : null;
        $this->container['description'] = isset($data['description']) ? $data['description'] : null;
        $this->container['required'] = isset($data['required']) ? $data['required'] : null;
        $this->container['read_only'] = isset($data['read_only']) ? $data['read_only'] : null;
        $this->container['max_length'] = isset($data['max_length']) ? $data['max_length'] : null;
        $this->container['default_value'] = isset($data['default_value']) ? $data['default_value'] : null;
        $this->container['possible_answers'] = isset($data['possible_answers']) ? $data['possible_answers'] : null;
        $this->container['hide_empty_option'] = isset($data['hide_empty_option']) ? $data['hide_empty_option'] : null;
        $this->container['empty_value'] = isset($data['empty_value']) ? $data['empty_value'] : null;
        $this->container['pattern'] = isset($data['pattern']) ? $data['pattern'] : null;
        $this->container['show_extension'] = isset($data['show_extension']) ? $data['show_extension'] : null;
        $this->container['intl'] = isset($data['intl']) ? $data['intl'] : null;
        $this->container['show_first'] = isset($data['show_first']) ? $data['show_first'] : null;
        $this->container['show_middle'] = isset($data['show_middle']) ? $data['show_middle'] : null;
        $this->container['show_last'] = isset($data['show_last']) ? $data['show_last'] : null;
        $this->container['show_prefix'] = isset($data['show_prefix']) ? $data['show_prefix'] : null;
        $this->container['show_suffix'] = isset($data['show_suffix']) ? $data['show_suffix'] : null;
        $this->container['required_first'] = isset($data['required_first']) ? $data['required_first'] : null;
        $this->container['required_middle'] = isset($data['required_middle']) ? $data['required_middle'] : null;
        $this->container['required_last'] = isset($data['required_last']) ? $data['required_last'] : null;
        $this->container['prefixes'] = isset($data['prefixes']) ? $data['prefixes'] : null;
        $this->container['suffixes'] = isset($data['suffixes']) ? $data['suffixes'] : null;
        $this->container['ca_provinces'] = isset($data['ca_provinces']) ? $data['ca_provinces'] : null;
        $this->container['countries'] = isset($data['countries']) ? $data['countries'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['title'] === null) {
            $invalidProperties[] = "'title' can't be null";
        }
        if ($this->container['description'] === null) {
            $invalidProperties[] = "'description' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type Type of question
     *
     * @return $this
     */
    public function setType($type)
    {
        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets title
     *
     * @return string
     */
    public function getTitle()
    {
        return $this->container['title'];
    }

    /**
     * Sets title
     *
     * @param string $title Question title
     *
     * @return $this
     */
    public function setTitle($title)
    {
        $this->container['title'] = $title;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string $description Question description/additional instructions.
     *
     * @return $this
     */
    public function setDescription($description)
    {
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets required
     *
     * @return bool
     */
    public function getRequired()
    {
        return $this->container['required'];
    }

    /**
     * Sets required
     *
     * @param bool $required Value is `true` if an answer to the question is required.
     *
     * @return $this
     */
    public function setRequired($required)
    {
        $this->container['required'] = $required;

        return $this;
    }

    /**
     * Gets read_only
     *
     * @return bool
     */
    public function getReadOnly()
    {
        return $this->container['read_only'];
    }

    /**
     * Sets read_only
     *
     * @param bool $read_only Value is `true` if the question should be rendered in the UI as read only.
     *
     * @return $this
     */
    public function setReadOnly($read_only)
    {
        $this->container['read_only'] = $read_only;

        return $this;
    }

    /**
     * Gets max_length
     *
     * @return float
     */
    public function getMaxLength()
    {
        return $this->container['max_length'];
    }

    /**
     * Sets max_length
     *
     * @param float $max_length Maximum text length allowed for questions of type `text` and `email`.
     *
     * @return $this
     */
    public function setMaxLength($max_length)
    {
        $this->container['max_length'] = $max_length;

        return $this;
    }

    /**
     * Gets default_value
     *
     * @return string
     */
    public function getDefaultValue()
    {
        return $this->container['default_value'];
    }

    /**
     * Sets default_value
     *
     * @param string $default_value Default value.  Exists only for questions of type `dropdown`, `checkboxes`, and `radio`.
     *
     * @return $this
     */
    public function setDefaultValue($default_value)
    {
        $this->container['default_value'] = $default_value;

        return $this;
    }

    /**
     * Gets possible_answers
     *
     * @return \Swagger\Client\Model\InlineResponse2005PossibleAnswers[]
     */
    public function getPossibleAnswers()
    {
        return $this->container['possible_answers'];
    }

    /**
     * Sets possible_answers
     *
     * @param \Swagger\Client\Model\InlineResponse2005PossibleAnswers[] $possible_answers List of possible answers.  Exists only for questions of type `dropdown`, `checkboxes`, and `radio`.
     *
     * @return $this
     */
    public function setPossibleAnswers($possible_answers)
    {
        $this->container['possible_answers'] = $possible_answers;

        return $this;
    }

    /**
     * Gets hide_empty_option
     *
     * @return bool
     */
    public function getHideEmptyOption()
    {
        return $this->container['hide_empty_option'];
    }

    /**
     * Sets hide_empty_option
     *
     * @param bool $hide_empty_option Value is `true` if the UI should not show an empty option.  For example, the dropdown might by default say 'Select One', but if this value is true then 'Select One' should not be shown.
     *
     * @return $this
     */
    public function setHideEmptyOption($hide_empty_option)
    {
        $this->container['hide_empty_option'] = $hide_empty_option;

        return $this;
    }

    /**
     * Gets empty_value
     *
     * @return string
     */
    public function getEmptyValue()
    {
        return $this->container['empty_value'];
    }

    /**
     * Sets empty_value
     *
     * @param string $empty_value Defines what is considered an empty value for this question.  For example, the value 'U' might be considered an empty value and will throw a validation error if this value is selected.  Exists only for questions of type `dropdown`, `checkboxes`, and `radio`.
     *
     * @return $this
     */
    public function setEmptyValue($empty_value)
    {
        $this->container['empty_value'] = $empty_value;

        return $this;
    }

    /**
     * Gets pattern
     *
     * @return string
     */
    public function getPattern()
    {
        return $this->container['pattern'];
    }

    /**
     * Sets pattern
     *
     * @param string $pattern Regular expression to validate input against.  Exists only for questions of type `email`.
     *
     * @return $this
     */
    public function setPattern($pattern)
    {
        $this->container['pattern'] = $pattern;

        return $this;
    }

    /**
     * Gets show_extension
     *
     * @return bool
     */
    public function getShowExtension()
    {
        return $this->container['show_extension'];
    }

    /**
     * Sets show_extension
     *
     * @param bool $show_extension Value is `true` if phone extension number should be rendered in UI.  Exists only for questions of type `phone`.
     *
     * @return $this
     */
    public function setShowExtension($show_extension)
    {
        $this->container['show_extension'] = $show_extension;

        return $this;
    }

    /**
     * Gets intl
     *
     * @return bool
     */
    public function getIntl()
    {
        return $this->container['intl'];
    }

    /**
     * Sets intl
     *
     * @param bool $intl Value is `true` if this is an international address or phone number question.  Exists only for questions of type `phone` and `address`.
     *
     * @return $this
     */
    public function setIntl($intl)
    {
        $this->container['intl'] = $intl;

        return $this;
    }

    /**
     * Gets show_first
     *
     * @return bool
     */
    public function getShowFirst()
    {
        return $this->container['show_first'];
    }

    /**
     * Sets show_first
     *
     * @param bool $show_first Value is `true` if first name should be rendered in UI.  Exists only for questions of type `name`.
     *
     * @return $this
     */
    public function setShowFirst($show_first)
    {
        $this->container['show_first'] = $show_first;

        return $this;
    }

    /**
     * Gets show_middle
     *
     * @return bool
     */
    public function getShowMiddle()
    {
        return $this->container['show_middle'];
    }

    /**
     * Sets show_middle
     *
     * @param bool $show_middle Value is `true` if middle name should be rendered in UI.  Exists only for questions of type `name`.
     *
     * @return $this
     */
    public function setShowMiddle($show_middle)
    {
        $this->container['show_middle'] = $show_middle;

        return $this;
    }

    /**
     * Gets show_last
     *
     * @return bool
     */
    public function getShowLast()
    {
        return $this->container['show_last'];
    }

    /**
     * Sets show_last
     *
     * @param bool $show_last Value is `true` if last name should be rendered in UI.  Exists only for questions of type `name`.
     *
     * @return $this
     */
    public function setShowLast($show_last)
    {
        $this->container['show_last'] = $show_last;

        return $this;
    }

    /**
     * Gets show_prefix
     *
     * @return bool
     */
    public function getShowPrefix()
    {
        return $this->container['show_prefix'];
    }

    /**
     * Sets show_prefix
     *
     * @param bool $show_prefix Value is `true` if name prefix should be rendered in UI.  Exists only for questions of type `name`.
     *
     * @return $this
     */
    public function setShowPrefix($show_prefix)
    {
        $this->container['show_prefix'] = $show_prefix;

        return $this;
    }

    /**
     * Gets show_suffix
     *
     * @return bool
     */
    public function getShowSuffix()
    {
        return $this->container['show_suffix'];
    }

    /**
     * Sets show_suffix
     *
     * @param bool $show_suffix Value is `true` if name suffix should be rendered in UI.  Exists only for questions of type `name`.
     *
     * @return $this
     */
    public function setShowSuffix($show_suffix)
    {
        $this->container['show_suffix'] = $show_suffix;

        return $this;
    }

    /**
     * Gets required_first
     *
     * @return bool
     */
    public function getRequiredFirst()
    {
        return $this->container['required_first'];
    }

    /**
     * Sets required_first
     *
     * @param bool $required_first Value is `true` if first name is required.  Exists only for questions of type `name`.
     *
     * @return $this
     */
    public function setRequiredFirst($required_first)
    {
        $this->container['required_first'] = $required_first;

        return $this;
    }

    /**
     * Gets required_middle
     *
     * @return bool
     */
    public function getRequiredMiddle()
    {
        return $this->container['required_middle'];
    }

    /**
     * Sets required_middle
     *
     * @param bool $required_middle Value is `true` if middle name is required.  Exists only for questions of type `name`.
     *
     * @return $this
     */
    public function setRequiredMiddle($required_middle)
    {
        $this->container['required_middle'] = $required_middle;

        return $this;
    }

    /**
     * Gets required_last
     *
     * @return bool
     */
    public function getRequiredLast()
    {
        return $this->container['required_last'];
    }

    /**
     * Sets required_last
     *
     * @param bool $required_last Value is `true` if last name is required.  Exists only for questions of type `name`.
     *
     * @return $this
     */
    public function setRequiredLast($required_last)
    {
        $this->container['required_last'] = $required_last;

        return $this;
    }

    /**
     * Gets prefixes
     *
     * @return \Swagger\Client\Model\InlineResponse2005Prefixes[]
     */
    public function getPrefixes()
    {
        return $this->container['prefixes'];
    }

    /**
     * Sets prefixes
     *
     * @param \Swagger\Client\Model\InlineResponse2005Prefixes[] $prefixes List of available name prefixes.
     *
     * @return $this
     */
    public function setPrefixes($prefixes)
    {
        $this->container['prefixes'] = $prefixes;

        return $this;
    }

    /**
     * Gets suffixes
     *
     * @return \Swagger\Client\Model\InlineResponse2005Suffixes[]
     */
    public function getSuffixes()
    {
        return $this->container['suffixes'];
    }

    /**
     * Sets suffixes
     *
     * @param \Swagger\Client\Model\InlineResponse2005Suffixes[] $suffixes List of available name suffixes.
     *
     * @return $this
     */
    public function setSuffixes($suffixes)
    {
        $this->container['suffixes'] = $suffixes;

        return $this;
    }

    /**
     * Gets ca_provinces
     *
     * @return \Swagger\Client\Model\InlineResponse2005CaProvinces[]
     */
    public function getCaProvinces()
    {
        return $this->container['ca_provinces'];
    }

    /**
     * Sets ca_provinces
     *
     * @param \Swagger\Client\Model\InlineResponse2005CaProvinces[] $ca_provinces Canada province list.  Exists only for questions of type `address` when `intl` is true.
     *
     * @return $this
     */
    public function setCaProvinces($ca_provinces)
    {
        $this->container['ca_provinces'] = $ca_provinces;

        return $this;
    }

    /**
     * Gets countries
     *
     * @return \Swagger\Client\Model\InlineResponse2005Countries[]
     */
    public function getCountries()
    {
        return $this->container['countries'];
    }

    /**
     * Sets countries
     *
     * @param \Swagger\Client\Model\InlineResponse2005Countries[] $countries Country list.  Exists only for questions of type `address` when `intl` is true.
     *
     * @return $this
     */
    public function setCountries($countries)
    {
        $this->container['countries'] = $countries;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


